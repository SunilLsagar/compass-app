"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryResponseErrorHandler = exports.retryResponseHandler = exports.retryRequestHandler = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const defaultConfig = {
    maxRequests: 5,
    retryLimit: 5,
    retryDelay: 300,
};
const retryRequestHandler = (req) => {
    req.retryCount = req.retryCount || 0;
    return req;
};
exports.retryRequestHandler = retryRequestHandler;
const retryResponseHandler = (response) => response;
exports.retryResponseHandler = retryResponseHandler;
const retryResponseErrorHandler = (error, config) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let retryCount = error.config.retryCount;
    // let retryErrorType = null;
    config = Object.assign(Object.assign({}, defaultConfig), config);
    if (!error.config.retryOnError || retryCount > config.retryLimit) {
        return Promise.reject(error);
    }
    const response = error.response;
    if (!response) {
        if (error.code === 'ECONNABORTED') {
            error.response = Object.assign(Object.assign({}, error.response), { status: 408, statusText: `timeout of ${config.timeout}ms exceeded` });
            return Promise.resolve(error.response);
        }
        else {
            return Promise.reject(error);
        }
    }
    else if (response.status == 429 || response.status == 401) {
        retryCount++;
        // retryErrorType = `Error with status: ${response.status}`;
        if (retryCount > config.retryLimit) {
            return Promise.reject(error);
        }
        yield new Promise((resolve) => setTimeout(resolve, 1000));
        error.config.retryCount = retryCount;
        return (0, axios_1.default)(error.request);
    }
    if (config.retryCondition && config.retryCondition(error)) {
        // retryErrorType = error.response ? `Error with status: ${response.status}` : `Error Code:${error.code}`;
        retryCount++;
        return retry(error, config, retryCount, config.retryDelay);
    }
});
exports.retryResponseErrorHandler = retryResponseErrorHandler;
const retry = (error, config, retryCount, retryDelay) => {
    let delayTime = retryDelay;
    if (retryCount > config.retryLimit) {
        return Promise.reject(error);
    }
    delayTime = config.retryDelay;
    error.config.retryCount = retryCount;
    return new Promise(function (resolve) {
        return setTimeout(function () {
            return resolve((0, axios_1.default)(error.request));
        }, delayTime);
    });
};
//# sourceMappingURL=delivery-sdk-handlers.js.map