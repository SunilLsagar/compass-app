import { __awaiter } from "tslib";
import { httpClient, retryRequestHandler, retryResponseErrorHandler, retryResponseHandler } from '@contentstack/core';
import { handleRequest } from './cache';
import { Stack as StackClass } from './stack';
import { Policy } from './types';
import { getHost } from './utils';
export * as Utils from '@contentstack/utils';
/**
 * @method stack
 * @memberof Contentstack
 * @description Creates a stack instance
 * @param {StackConfig} config - config object for stack with apiKey, deliveryToken and environment as required fields
 *
 * @example
 * import contentstack from '@contentstack/delivery-sdk'
 * const stack = contentstack.Stack({ apiKey: "apiKey", deliveryToken: "deliveryToken", environment: "environment" });
 * @example
 * import contentstack from '@contentstack/delivery-sdk'
 * const stack = contentstack.Stack({
 *   apiKey: "apiKey",
 *   deliveryToken: "deliveryToken",
 *   environment: "environment",
 *   region:"region",
 *   locale:"locale",
 *   cacheOptions: {
 *    policy: Policy.CACHE_THEN_NETWORK,
 *    storeType: 'localStorage'
 *   }
 * }
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
export function stack(config) {
    var _a, _b, _c, _d, _e;
    let defaultConfig = {
        defaultHostname: 'cdn.contentstack.io',
        headers: {},
        params: {},
        live_preview: {}
    };
    if (((_a = config.live_preview) === null || _a === void 0 ? void 0 : _a.enable) === true) {
        if (((_b = config.live_preview) === null || _b === void 0 ? void 0 : _b.management_token) != null && ((_c = config.live_preview) === null || _c === void 0 ? void 0 : _c.preview_token) == null) {
            config.host = 'api.contentstack.io';
            config.live_preview.host = config.host;
        }
        else if (((_d = config.live_preview) === null || _d === void 0 ? void 0 : _d.preview_token) != null && ((_e = config.live_preview) === null || _e === void 0 ? void 0 : _e.management_token) == null) {
            config.host = 'rest-preview.contentstack.com';
            config.live_preview.host = config.host;
        }
    }
    else
        config.host = defaultConfig.defaultHostname;
    defaultConfig.live_preview = config.live_preview;
    defaultConfig.defaultHostname = getHost(config.region, config.host);
    if (config.apiKey) {
        defaultConfig.headers.api_key = config.apiKey;
    }
    else {
        throw new Error('API key for Stack is required.');
    }
    if (config.deliveryToken) {
        defaultConfig.headers.access_token = config.deliveryToken;
    }
    else {
        throw new Error('Delivery token for Stack is required.');
    }
    if (config.environment) {
        defaultConfig.params.environment = config.environment;
    }
    else {
        throw new Error('Environment for Stack is required');
    }
    if (config.early_access) {
        defaultConfig.headers['x-header-ea'] = config.early_access.join(',');
    }
    // return new Stack(httpClient(defaultConfig), config);
    const client = httpClient(defaultConfig);
    if (config.logHandler)
        client.defaults.logHandler = config.logHandler;
    if (config.cacheOptions && config.cacheOptions.policy !== Policy.IGNORE_CACHE) {
        const defaultAdapter = client.defaults.adapter;
        client.defaults.adapter = (adapterConfig) => {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (config.cacheOptions)
                    yield handleRequest(config.cacheOptions, config.apiKey, defaultAdapter, resolve, reject, adapterConfig);
            }));
        };
    }
    // Retry policy handlers
    const errorHandler = (error) => {
        retryResponseErrorHandler(error, config);
    };
    client.interceptors.request.use(retryRequestHandler);
    client.interceptors.response.use(retryResponseHandler, errorHandler);
    if (config.plugins) {
        client.interceptors.request.use((reqConfig) => {
            if (config && config.plugins)
                config.plugins.forEach((pluginInstance) => {
                    reqConfig = pluginInstance.onRequest(reqConfig);
                });
            return reqConfig;
        });
        client.interceptors.response.use((response) => {
            if (config && config.plugins)
                config.plugins.forEach((pluginInstance) => {
                    response = pluginInstance.onResponse(response.request, response, response.data);
                });
            return response;
        });
    }
    return new StackClass(client, config);
}
//# sourceMappingURL=contentstack.js.map