"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stack = exports.Utils = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@contentstack/core");
const cache_1 = require("./cache");
const stack_1 = require("./stack");
const types_1 = require("./types");
const utils_1 = require("./utils");
exports.Utils = tslib_1.__importStar(require("@contentstack/utils"));
/**
 * @method stack
 * @memberof Contentstack
 * @description Creates a stack instance
 * @param {StackConfig} config - config object for stack with apiKey, deliveryToken and environment as required fields
 *
 * @example
 * import contentstack from '@contentstack/delivery-sdk'
 * const stack = contentstack.Stack({ apiKey: "apiKey", deliveryToken: "deliveryToken", environment: "environment" });
 * @example
 * import contentstack from '@contentstack/delivery-sdk'
 * const stack = contentstack.Stack({
 *   apiKey: "apiKey",
 *   deliveryToken: "deliveryToken",
 *   environment: "environment",
 *   region:"region",
 *   locale:"locale",
 *   cacheOptions: {
 *    policy: Policy.CACHE_THEN_NETWORK,
 *    storeType: 'localStorage'
 *   }
 * }
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function stack(config) {
    var _a, _b, _c, _d, _e;
    let defaultConfig = {
        defaultHostname: 'cdn.contentstack.io',
        headers: {},
        params: {},
        live_preview: {}
    };
    if (((_a = config.live_preview) === null || _a === void 0 ? void 0 : _a.enable) === true) {
        if (((_b = config.live_preview) === null || _b === void 0 ? void 0 : _b.management_token) != null && ((_c = config.live_preview) === null || _c === void 0 ? void 0 : _c.preview_token) == null) {
            config.host = 'api.contentstack.io';
            config.live_preview.host = config.host;
        }
        else if (((_d = config.live_preview) === null || _d === void 0 ? void 0 : _d.preview_token) != null && ((_e = config.live_preview) === null || _e === void 0 ? void 0 : _e.management_token) == null) {
            config.host = 'rest-preview.contentstack.com';
            config.live_preview.host = config.host;
        }
    }
    else
        config.host = defaultConfig.defaultHostname;
    defaultConfig.live_preview = config.live_preview;
    defaultConfig.defaultHostname = (0, utils_1.getHost)(config.region, config.host);
    if (config.apiKey) {
        defaultConfig.headers.api_key = config.apiKey;
    }
    else {
        throw new Error('API key for Stack is required.');
    }
    if (config.deliveryToken) {
        defaultConfig.headers.access_token = config.deliveryToken;
    }
    else {
        throw new Error('Delivery token for Stack is required.');
    }
    if (config.environment) {
        defaultConfig.params.environment = config.environment;
    }
    else {
        throw new Error('Environment for Stack is required');
    }
    if (config.early_access) {
        defaultConfig.headers['x-header-ea'] = config.early_access.join(',');
    }
    // return new Stack(httpClient(defaultConfig), config);
    const client = (0, core_1.httpClient)(defaultConfig);
    if (config.logHandler)
        client.defaults.logHandler = config.logHandler;
    if (config.cacheOptions && config.cacheOptions.policy !== types_1.Policy.IGNORE_CACHE) {
        const defaultAdapter = client.defaults.adapter;
        client.defaults.adapter = (adapterConfig) => {
            return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (config.cacheOptions)
                    yield (0, cache_1.handleRequest)(config.cacheOptions, config.apiKey, defaultAdapter, resolve, reject, adapterConfig);
            }));
        };
    }
    // Retry policy handlers
    const errorHandler = (error) => {
        (0, core_1.retryResponseErrorHandler)(error, config);
    };
    client.interceptors.request.use(core_1.retryRequestHandler);
    client.interceptors.response.use(core_1.retryResponseHandler, errorHandler);
    if (config.plugins) {
        client.interceptors.request.use((reqConfig) => {
            if (config && config.plugins)
                config.plugins.forEach((pluginInstance) => {
                    reqConfig = pluginInstance.onRequest(reqConfig);
                });
            return reqConfig;
        });
        client.interceptors.response.use((response) => {
            if (config && config.plugins)
                config.plugins.forEach((pluginInstance) => {
                    response = pluginInstance.onResponse(response.request, response, response.data);
                });
            return response;
        });
    }
    return new stack_1.Stack(client, config);
}
exports.stack = stack;
//# sourceMappingURL=contentstack.js.map